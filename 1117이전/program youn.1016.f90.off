program youn

    ! 1015일의 목표는 
    !쿼드락쳐 노드 더 만들기 
    ! 그림은 박사님오면 물어보기 
    ! 르잔드르 다항식(스케일드) 점검하기 
    ! 오류 잡기 


    implicit none 
    ! DG ORDER 
    integer,parameter :: Dg_ord =3
    integer,parameter :: Legendre_ord = Dg_ord-1 

    ! Useful parameter 
    !double precision,parameter :: pi = 4.0d0*datan(1.0d0)

    !Spatial variables
    integer,parameter :: imax=50*(2**0) !Number of spatial cells

    double precision,parameter :: x_left=-1.0d0 !Left boundary on x-axis
    double precision,parameter :: x_right=1.0d0 !Right boundary on x-axis
    !double precision,parameter :: x_length=dabs(x_right-x_left) !Length of domain

    double precision,dimension(1:imax) :: x !Cell centers
    double precision,dimension(1:imax) :: dx !Cell volumes
    double precision,dimension(1:imax) :: sum_u_0

    double precision,dimension(1:imax,0:Legendre_ord) :: u_0


    double precision,dimension(1:6,1:2) :: Q 
    double precision,dimension(0:Legendre_ord,0:Legendre_ord) :: M 

    double precision, external :: Ini_u 
    double precision,external :: Le_poly 

    integer :: i 


    write(*,*) " "
    write(*,*) "**   윤상은 practice   **"
    write(*,*) " "
    write(*,*) " "


    call Get_Quadrature(7,Q)
    call Get_Mass(Legendre_ord,Q,M)
    call Get_Spatial(imax,x_left,x_right,x,dx)
    call Get_Initial(Legendre_ord,Q,M, imax,x,dx,u_0,sum_u_0)


        ! 예: 결과 벡터 u(1:imax)을 파일로 저장
    open(unit=10, file='result.dat2', status='unknown')
    do i = 1, imax
        write(10,*) x(i), sum_u_0(i)
    enddo
    close(10)

endprogram


! 적분할때, 노드의 위치와 가중치들을 알려주는 함수
! ord에 따라서 노드와 가중치가 달라진다. 
! 박사님 --> scaled 된 걸 사용 왜그랬을까? 
! 일단 나도 scaled 된걸 사용하겠다. 
! ord --> 사용하는 점의 개수 
! 즉 점이 n개면 2n-1차 다항식까지 완벽하게 표현 가능! 

! 왜 박사님은 -1/2 에서 1/2 로 scaled 된 걸 사용했을까..? !!!!!!!!!!!!!!!!!!!!!!
subroutine Get_Quadrature(ord,Q) 

    implicit none

    integer,intent(in) :: ord 

    double precision,intent(out) ::Q(1:6,1:2)

    Q = 0.0d0
    
    select case(ord)

        ! case 2 3 4 는 가우시안 쿼드락쳐 를 사용한 것 
        ! 2 3 4 는 각각 점의 개수 
        case (2) 
            Q(1,1) = -dsqrt(3.0d0) / 3.0d0 / 2.0d0
            Q(2,1) = +dsqrt(3.0d0) / 3.0d0 / 2.0d0
            
            Q(1,2) = 1.0d0 / 2.0d0
            Q(2,2) = 1.0d0 / 2.0d0

        case (3) 
            Q(1,1) = -dsqrt(15.0d0) / 5.0d0 / 2.0d0
            Q(2,1) = 0.0d0
            Q(3,1) = +dsqrt(15.0d0) / 5.0d0 / 2.0d0

            Q(1,2) = 5.0d0 / 9.0d0 / 2.0d0
            Q(2,2) = 8.0d0 / 9.0d0 / 2.0d0
            Q(3,2) = 5.0d0 / 9.0d0 / 2.0d0

        case(4) 
            Q(1,1) = -dsqrt(3.0d0 / 7.0d0 + 2.0d0 / 7.0d0 * dsqrt(6.0d0 / 5.0d0)) / 2.0d0
            Q(2,1) = -dsqrt(3.0d0 / 7.0d0 - 2.0d0 / 7.0d0 * dsqrt(6.0d0 / 5.0d0)) / 2.0d0
            Q(3,1) = +dsqrt(3.0d0 / 7.0d0 - 2.0d0 / 7.0d0 * dsqrt(6.0d0 / 5.0d0)) / 2.0d0
            Q(4,1) = +dsqrt(3.0d0 / 7.0d0 + 2.0d0 / 7.0d0 * dsqrt(6.0d0 / 5.0d0)) / 2.0d0

            Q(1,2) = (18.0d0 - dsqrt(30.0d0))/36.0d0 / 2.0d0
            Q(2,2) = (18.0d0 + dsqrt(30.0d0))/36.0d0 / 2.0d0
            Q(3,2) = (18.0d0 + dsqrt(30.0d0))/36.0d0 / 2.0d0
            Q(4,2) = (18.0d0 - dsqrt(30.0d0))/36.0d0 / 2.0d0

        case(5) 
            !점 4개를 사용하는 가우시안 로바또 쿼드락쳐 
            Q(1,1) = -1.0d0/2.0d0
            Q(2,1) = -dsqrt(5.0d0)/5.0d0 / 2
            Q(3,1) = +dsqrt(5.0d0)/5.0d0 / 2
            Q(4,1) = +1.0d0/2.0d0

            Q(1,2) = 1.0d0/12.0d0
            Q(2,2) = 5.0d0/12.0d0
            Q(3,2) = 5.0d0/12.0d0
            Q(4,2) = 1.0d0/12.0d0

        case(6)  ! 노드 5개 가우시안 로바또 
            Q(1,1) = -1.0d0/2.0d0
            Q(2,1) = -sqrt(5.0d0/7.0d0) / 2.0d0
            Q(3,1) =  0.0d0
            Q(4,1) = +sqrt(5.0d0/7.0d0) / 2.0d0
            Q(5,1) = +1.0d0/2.0d0

            Q(1,2) = 1.0d0/20.0d0
            Q(2,2) = 49.0d0/90.0d0
            Q(3,2) = 64.0d0/90.0d0
            Q(4,2) = 49.0d0/90.0d0
            Q(5,2) = 1.0d0/20.0d0

        case(7) 
            Q(1,1) = -1.0d0/2.0d0
            Q(2,1) = -sqrt(1.0d0/3.0d0 + 2.0d0/7.0d0 * sqrt(6.0d0/5.0d0)) /2.0d0 
            Q(3,1) = -sqrt(1.0d0/3.0d0 - 2.0d0/7.0d0 * sqrt(6.0d0/5.0d0)) /2.0d0
            Q(4,1) = +sqrt(1.0d0/3.0d0 - 2.0d0/7.0d0 * sqrt(6.0d0/5.0d0)) /2.0d0
            Q(5,1) = +sqrt(1.0d0/3.0d0 + 2.0d0/7.0d0 * sqrt(6.0d0/5.0d0)) /2.0d0
            Q(6,1) = +1.0d0/2.0d0

            Q(1,2) = 1.0d0/30.0d0
            Q(2,2) = 27.0d0/105.0d0
            Q(3,2) = 32.0d0/105.0d0
            Q(4,2) = 32.0d0/105.0d0
            Q(5,2) = 27.0d0/105.0d0
            Q(6,2) = 1.0d0/30.0d0

        case default 
            print * , "order는 숫자여야하고, 7이하여야합니다. "
        
    end select

    return 
endsubroutine


subroutine Get_Mass(Legendre_ord,Q,M)

    implicit none 
    integer, intent(in) :: Legendre_ord
    double precision, intent(in) :: Q(1:6,1:2)
    double precision, intent(out) :: M(0:Legendre_ord,0:Legendre_ord)

    integer :: i , j ,k 

    double precision,external :: Le_poly

    M = 0.0d0 

    ! -1/2에서 1/2 구간에서의 질량 행열 

    do i = 0,Legendre_ord
        do j = 0,Legendre_ord
            do k = 1,6
                M(i,j) = M(i,j) + Le_poly(i,Q(k,1)) * Le_poly(j,Q(k,1)) * Q(k,2)
            enddo

            if (M(i,j) > 1d-10) then
                M(i,j) = 1.0d0 / M(i,j)
            else 
                M(i,j) = 0.0d0 
            endif 
        enddo   
    enddo

    write(*,*) "===========================Mass matrix==========================="
    do i=0,Legendre_ord
        write(*,'(4G16.6)') M(i,:)
    enddo
    write(*,*) "================================================================="
    write(*,*) " "
    
    return
endsubroutine


! i_bc는 바운더리에서 근사할때 만들 필요가 있어서 필요한 거 (ghost cell) --> 나중에! 
! imax는 셀의 개수!!!!! 

! 즉 우리는 셀를 imax개로 쪼갤 거다!! 


subroutine Get_Spatial(imax, x_left,x_right,x,dx)
    implicit none 

    integer,intent(in) :: imax 

    double precision,intent(in) :: x_left,x_right

    double precision,intent(out) :: x(1:imax) , dx(1:imax)
    
    double precision :: x_length
    
    
    integer :: i 

    double precision,dimension(0:imax) :: temp_x 

    x_length = x_right - x_left
    ! 이 것은 정말 물리적인 공간만 나눠놓음! 
    ! temp_x(i) temp_x(i+1) 은 좌우 구간의 값임! 
    ! 지금 그리고, 균일하게 나눠놓음! 

    do i = 0,imax 
        temp_x(i) = x_left + i * dble(x_length)/dble(imax)
    enddo
    ! x는 각 셀의 중간을 의미함! x(i)는 i 번째 셀의 가운데를 의미 
    ! dx는 각 셀의 크기! dx(i)는 i번째 셀의 크기 
    do i = 1,imax
        x(i)= (temp_x(i-1) + temp_x(i))/2.0d0
        dx(i) = dabs(temp_x(i)-temp_x(i-1))
    enddo
    
    return
endsubroutine



! 무엇이 필요할까? 
! 초기 조건이 필요하지 않을까? 
subroutine Get_Initial(Legendre_ord, Q, M, imax, x, dx, u_0,sum_u_0)

    implicit none
    integer, intent(in) :: Legendre_ord
    
    double precision,intent(in) :: Q(1:6,1:2) 
    double precision,intent(in) :: M(0:Legendre_ord,0:Legendre_ord)
    integer,intent(in) :: imax

    double precision,intent(in) :: x(1:imax) , dx(1:imax) 

    double precision,external :: Le_poly
    double precision,external :: Ini_u

    double precision,intent(out) :: u_0(1:imax,0:Legendre_ord)
    double precision,intent(out) :: sum_u_0(1:imax)  

    double precision,dimension(1:imax) :: exact_u_0

    double precision,dimension(1:6) :: xq 
    double precision ::  temp_sum
    integer :: i ,j ,k , r

    u_0 = 0.0d0

    !! 여기 double do 문은 계수(dof) 만드는 작업 
    ! 여기서 i 인덱스는 셀의 순서를 이야기한다. (몇번 째 셀인지!)
    do i = 1 , imax 
        ! 이 작업은 내가 가지고 있는 quadrature 노드를 셀로 이동시키는 부분 
        ! 즉, 각 셀에서 quadrature 노드는 이제 xq 이다!! 
        do k = 1,6
            xq(k) =  dx(i) * Q(k,1) + x(i) 
        enddo

        ! j 인덱스는 order를 의미함 .
        ! degree of freedom에서는 order와 구간별(cell)로 dof를 정하므로, 인덱스가 2개 필요하다. 
        
        do j = 0 , Legendre_ord
            do r = 1,6 
                u_0(i,j) = u_0(i,j) + Ini_u(xq(r)) * Le_poly(j,Q(r,1)) * Q(r,2) 
                ! weight를 바꾸야하지 않나..? 자코비안 곱해야할 것 같은데.... & 노드를 그냥 원래 노드를 넣어도 될까? 
                ! --> 무척 신기하네.. 다 포함되어 있는 것임... Q(1,2)를 넣으므로 써 자코비안이 이미 곱해진 형태를 가지고 있다. 
            enddo

            u_0(i,j) = u_0(i,j) * M(j,j)
        enddo
    enddo

    ! 실제 우리가 구하고 싶은 거 만들기 
    do i =1,imax 
        temp_sum = 0.0d0 ! 셀마다 리셋시키는 용도 

        do j = 0, Legendre_ord
            temp_sum  = temp_sum + u_0(i,j) * Le_poly( j , 0.0d0 )   ! 왜 르잔드르 다항식에서 x 값을 0 이라고 두었을까..? --> 셀 중간 값을 비교할 것이므로, 그걸 원래 것으로 가지고 오면 0이므로!!! 
        enddo
        ! sum_u_0 은 cell i 에서 초기 값을 사영한 것! (결과물)
        sum_u_0(i) = temp_sum
    enddo

    ! 실제 값 만들기!!!! ---> 우리는 비교를 할건데, 어떻게 비교를 할 것이냐면~ 셀 중간값(x(i))에 값을 찍고, 그걸 사영한 다음에 잘 사영되어있는 지를 볼 것이다. 
    do i = 1 , imax 
        exact_u_0(i) = Ini_u(x(i))
    enddo 

    write(*,*) "======================Initial error results======================"
    call Get_L2_Error(imax,dx,exact_u_0,sum_u_0)
     write(*,*) "================================================================="
    write(*,*) " "

    return
endsubroutine

subroutine Get_L2_Error(imax,dx,exact,numerical)
    implicit none

    integer,intent(in) :: imax 
    double precision,intent(in) :: dx(1:imax)
    double precision,intent(in) :: exact(1:imax), numerical(1:imax) 
    double precision :: Error 
    
    integer :: i 
    double precision,dimension(1:imax) :: temp_dif

    do i = 1, imax  

        temp_dif(i) = (exact(i) - numerical(i))**2
        temp_dif(i) = temp_dif(i) *dx(i)  ! 적분해야하므로, 구간을 곱해서 면적을 구해준다. 
    enddo

    Error = dsqrt(sum(temp_dif)) 

    write(*,*) " L2 Error :  " , Error 

    return
endsubroutine   


double precision function Ini_u(x) 
    implicit none 

    double precision,intent(in) :: x 

    ! Useful constant
    double precision,parameter :: pi=4.0d0*datan(1.0d0)

    ! smooth function 
    Ini_u = dsin(pi*x) 
    ! Ini_u = dexp(x)

    ! non-smooth function
    !if (x < -0.5d0 .or. x >0.5d0) then   
    !    Ini_u = 0.0d0
    !else   
    !    Ini_u = 1.0d0
    !endif


    return
endfunction

! 르잔드르 다항식 근데 구간이 -1/2 에서 1/2 로 스케일드 되어 있음! 
double precision function Le_poly(ord, x) 
    implicit none

    integer,intent(in) :: ord 
    double precision,intent(in) :: x 

    select case(ord) 
    case(0) 
        Le_poly = 1 
    case(1) 
        Le_poly = x**1
    case(2)
        Le_poly = x**2 - (1.0d0/12.0d0) 
    case(3) 
        Le_poly = x**3 - (3.0d0 /20.0d0) * x 
    case(4) 
        Le_poly = (x**4) - ((3.0d0 / 14.0d0) * x**2) + (3.0d0 / 560.0d0)
    case default 
        Le_poly = 0.0d0
    end select

    return
endfunction