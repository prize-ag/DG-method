program youn

    implicit none 

    integer,parameter :: Dg_ord =3 
    integer,parameter :: Legendre_ord = Dg_ord-1 

    double precision,parameter :: pi = 4.0d0*datan(1.0d0)
    double precision,parameter :: CFL = 0.5d0/dble(2*Legendre_ord+1) 
    double precision,parameter :: TVB_M =1.0d0

    !Spatial variables
    integer,parameter :: imax=50*(2**0) !Number of spatial cells
    integer,parameter :: i_bc=2*Legendre_ord+1 !Ghost boundary cells for WENO schemes
    double precision,parameter :: x_left=-1.0d0 !Left boundary on x-axis
    double precision,parameter :: x_right=1.0d0 !Right boundary on x-axis
    double precision,parameter :: x_length=dabs(x_right-x_left) !Length of domain
    double precision,dimension(1:imax) :: x !Cell centers
    double precision,dimension(1:imax) :: dx !Cell volumes


    double precision,dimension(1:6,1:2) :: Q = 0 

    double precision, external :: Ini_u 

    double precision,external :: Le_poly 

    double precision,dimension(0:Legendre_ord,0:Legendre_ord) :: M 


    write(*,*) " "
    write(*,*) "**   윤상은 practice   **"
    write(*,*) " "
    write(*,*) " "


    call Get_Quadrature(4,Q)
    call Get_Mass(Legendre_ord,Q,M)
    call Get_Spatial(imax,x_left,x_right,x,dx)

endprogram


! 적분할때, 노드의 위치와 가중치들을 알려주는 함수
! ord에 따라서 노드와 가중치가 달라진다. 
! 박사님 --> scaled 된 걸 사용 왜그랬을까? 
! 일단 나도 scaled 된걸 사용하겠다. 
! ord --> 사용하는 점의 개수 
! 즉 점이 n개면 2n-1차 다항식까지 완벽하게 표현 가능! 

! 왜 박사님은 -1/2 에서 1/2 로 scaled 된 걸 사용했을까..? !!!!!!!!!!!!!!!!!!!!!!
subroutine Get_Quadrature(ord,Q) 

    implicit none

    integer,intent(in) :: ord 

    double precision,intent(out) ::Q(1:6,1:2)

    Q = 0.0d0
    
    select case(ord)

        case (2) 
            Q(1,1) = -dsqrt(3.0d0) / 3.0d0 / 2.0d0
            Q(2,1) = +dsqrt(3.0d0) / 3.0d0 / 2.0d0
            
            Q(1,2) = 1.0d0 / 2.0d0
            Q(2,2) = 1.0d0 / 2.0d0

        case (3) 
            Q(1,1) = -dsqrt(15.0d0) / 5.0d0 / 2.0d0
            Q(2,1) = 0.0d0
            Q(3,1) = +dsqrt(15.0d0) / 5.0d0 / 2.0d0

            Q(1,2) = 5.0d0 / 9.0d0 / 2.0d0
            Q(2,2) = 8.0d0 / 9.0d0 / 2.0d0
            Q(3,2) = 5.0d0 / 9.0d0 / 2.0d0

        case(4) 
            Q(1,1) = -dsqrt(3.0d0 / 7.0d0 + 2.0d0 / 7.0d0 * dsqrt(6.0d0 / 5.0d0)) / 2.0d0
            Q(2,1) = -dsqrt(3.0d0 / 7.0d0 - 2.0d0 / 7.0d0 * dsqrt(6.0d0 / 5.0d0)) / 2.0d0
            Q(3,1) = +dsqrt(3.0d0 / 7.0d0 - 2.0d0 / 7.0d0 * dsqrt(6.0d0 / 5.0d0)) / 2.0d0
            Q(4,1) = +dsqrt(3.0d0 / 7.0d0 + 2.0d0 / 7.0d0 * dsqrt(6.0d0 / 5.0d0)) / 2.0d0

            Q(1,2) = (18.0d0 - dsqrt(30.0d0))/36.0d0 / 2.0d0
            Q(2,2) = (18.0d0 + dsqrt(30.0d0))/36.0d0 / 2.0d0
            Q(3,2) = (18.0d0 + dsqrt(30.0d0))/36.0d0 / 2.0d0
            Q(4,2) = (18.0d0 - dsqrt(30.0d0))/36.0d0 / 2.0d0



        case default 
            print * , "order는 숫자여야하고, 7이하여야합니다. "
        
    end select

    return 
endsubroutine


subroutine Get_Mass(Legendre_ord,Q,M)

    implicit none 
    integer, intent(in) :: Legendre_ord
    double precision, intent(in) :: Q(1:6,1:2)
    double precision, intent(out) :: M(0:Legendre_ord,0:Legendre_ord)

    integer :: i , j 

    double precision,external :: Le_poly

    do i = 0,Legendre_ord
        do j = 0,Legendre_ord
            M(i,j)&
            &= Le_poly(i,Q(1,1)) * Le_poly(j,Q(1,1)) * Q(1,2)&
            &+ Le_poly(i,Q(2,1)) * Le_poly(j,Q(2,1)) * Q(2,2)&
            &+ Le_poly(i,Q(3,1)) * Le_poly(j,Q(3,1)) * Q(3,2)&
            &+ Le_poly(i,Q(4,1)) * Le_poly(j,Q(4,1)) * Q(4,2)&
            &+ Le_poly(i,Q(5,1)) * Le_poly(j,Q(5,1)) * Q(5,2)&
            &+ Le_poly(i,Q(6,1)) * Le_poly(j,Q(6,1)) * Q(6,2)

            if (M(i,j).ge.1d-10) then
                M(i,j) = 1.0d0/M(i,j)
            else 
                M(i,j) = 0.0d0 
            endif 

        enddo   
    enddo

    write(*,*) "===========================Mass matrix==========================="
    do i=0,size(M,1)-1
        write(*,*) real(M(i,:))
    enddo

    write(*,*) "================================================================="
    write(*,*) " "
    return
endsubroutine


! i_bc는 바운더리에서 근사할때 만들 필요가 있어서 필요한 거 (ghost cell) --> 나중에! 
! imax는 셀의 개수!!!!! 

! 즉 우리는 셀를 imax개로 쪼갤 거다!! 


subroutine Get_Spatial(imax, x_left,x_right,x,dx)
    implicit none 

    integer,intent(in) :: imax 

    double precision,intent(in) :: x_left,x_right

    double precision,intent(out) :: x(1:imax) , dx(0:imax-1)
    
    double precision :: x_length
    
    
    integer :: i 

    double precision,dimension(0:imax) :: temp_x 

    x_length = x_right - x_left
    ! 이 것은 정말 물리적인 공간만 나눠놓음! 
    ! temp_x(i) temp_x(i+1) 은 좌우 구간의 값임! 
    ! 지금 그리고, 균일하게 나눠놓음! 

    do i = 0,imax 
        temp_x(i) = x_left + i * dble(x_length)/dble(imax)
    enddo
    ! x는 각 셀의 중간을 의미함! x(i)는 i 번째 셀의 가운데를 의미 
    ! dx는 각 셀의 크기! dx(i)는 i번째 셀의 크기 
    do i = 1,imax
        x(i)= (temp_x(i-1) + temp_x(i))/2.0d0
        dx(i) = dabs(temp_x(i)-temp_x(i-1))
    enddo
    
endsubroutine



! 무엇이 필요할까? 
! 초기 조건이 필요하지 않을까? 
subroutine Get_Initial(Legendre_ord, Q, M, imax, x, dx, u_0)

    implicit none
    integer, intent(in) :: Legendre_ord
    
    double precision,external :: Ini_u

    double precision,intent(in) :: Q(1:6,1:2) 
    double precision,intent(in) :: M(0:Legendre_ord,0:Legendre_ord)
    integer,intent(in) :: imax

    double precision,intent(in) :: x(1:imax) , dx(1:imax) 

    double precision,external :: Le_poly

    double precision,intent(out) :: u_0(1:imax,0:Legendre_ord)

    double precision,dimension(1:imax) :: exact_u_0 ,sum_u_0
    double precision :: x_1, x_2, x_3, x_4, x_5, x_6
    integer :: i ,j 



    !! 여기 double do 문은 계수(dof) 만드는 작업 
    ! 여기서 i 인덱스는 셀의 순서를 이야기한다. (몇번 째 셀인지!)
    do i = 1 , imax 
        ! 이 작업은 내가 가지고 있는 quadrature 노드를 셀로 이동시키는 부분 
        ! 즉, 각 셀에서 quadrature 노드는 이제 x_1~ x_6 이다!! 
        x_1 = dx(i) * Q(1,1) + x(i) 
        x_2 = dx(i) * Q(2,1) + x(i)
        x_3 = dx(i) * Q(3,1) + x(i) 
        x_4 = dx(i) * Q(4,1) + x(i) 
        x_5 = dx(i) * Q(5,1) + x(i) 
        x_6 = dx(i) * Q(6,1) + x(i) 

        ! j 인덱스는 order를 의미함 .
        ! degree of freedom에서는 order와 구간별로 dof를 정하므로, 인덱스가 2개 필요하다. 

        do j = 0 , Legendre_ord
            u_0(i,j) = Ini_u(x_1) * Le_poly(j,Q(1,1)) * Q(1,2)&   ! weight를 바꾸야하지 않나..? 자코비안 곱해야할 것 같은데.... 
                    &+ Ini_u(x_2) * Le_poly(j,Q(2,1)) * Q(2,2)&
                    &+ Ini_u(x_3) * Le_poly(j,Q(3,1)) * Q(3,2)&
                    &+ Ini_u(x_4) * Le_poly(j,Q(4,1)) * Q(4,2)&
                    &+ Ini_u(x_5) * Le_poly(j,Q(5,1)) * Q(5,2)&
                    &+ Ini_u(x_6) * Le_poly(j,Q(6,1)) * Q(6,2)

            u_0(i,j) = u_0(i,j) * M(j,j)
        enddo
    enddo

    ! 실제 우리가 구하고 싶은 거 만들기 
    



    ! 실제 값 만들기!!!! 
    do i = 1 , imax 
        exact_u_0 = Ini_u(x(i))
    enddo 


endsubroutine

double precision function Ini_u(x) 
    implicit none 

    double precision,intent(in) :: x 

    ! Useful constant
    double precision,parameter :: pi=4.0d0*datan(1.0d0)

    ! smooth function 
    Ini_u = dcos(pi*x) 
    ! Ini_u = dexp(x)

    ! non-smooth function
    !if (x < -0.5d0 .or. x >0.5d0) then   
    !    Ini_u = 0.0d0
    !else   
    !    Ini_u = 1.0d0
    !endif
 
    return
endfunction

! 르잔드르 다항식 근데 구간이 -1/2 에서 1/2 로 스케일드 되어 있음! 
double precision function Le_poly(ord, x) 
    implicit none

    integer,intent(in) :: ord 
    double precision,intent(in) :: x 

    select case(ord) 
    case(0) 
        Le_poly = 1 
    case(1) 
        Le_poly = x**1
    case(2)
        Le_poly = x**2 - (1.0d0/12.0d0) 
    case(3) 
        Le_poly = x**3 - (3.0d0 /20.0d0) * x 
    case(4) 
        Le_poly = (x**4) - ((3.0d0 / 14.0d0) * x**2) + (3.0d0 / 560.0d0)
    case default 
        Le_poly = 0.0d0
    end select

endfunction